# 스마트 포인터

포인터는 메모리의 주소값을 담고 있는 변수에 대한 일반적인 개념이다. 러스트에선 이를 참조자라고도 부르며 &심볼을 이용해 만들 수 있습니다.

스마트 포인터는 위 포인터 능력에 대해 메타데이터을 추가로 가지고 있는 데이터 구조입니다. 예를들어 참조 카운팅이라고,
소유자의 개수를 계속 추적하고 소유자가 없을 경우 데이터를 정리하는 이와 같은 메타데이터를 가질 수 있습니다.

스마트 포인터는 러스트에서 자주 사용되는 일반적인 디자인 패턴이며, 대표적으로 아래와 같은 패턴이 있다.
1. 값을 힙에 할당하기 위한 Box<T>
2. 복수 소유권을 가능하게 하는 참조 카운팅 Rc<T>
3. 빌림 규칙을 컴파일 타임 대신 런타임에 강제하는 타입, RefCell<T>를 통해 접근 가능한 Ref<T>, RefMut<T>
4. 내부 가변성 패턴

## 필수 Trait

스마트 포인터에서는 Deref와, Drop트레잇을 구현해야 하는데, 이 부분에 대해서 먼저 짚고 넘어가자.

### Deref Trait

Deref 트레잇은 역참조 연산자 *의 동작을 커스터마이징할 수 있게 해준다.

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
마지막 assert_eq!를 보면, 5와 역참조y의 값은 5로 동일하기에 성공하나, 역참조를 떼버리면 integer와 &integer를 비교할 수 없다고 에러를 만날 것 이다.

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```
이런식으로 Box타입을 사용하게되면 성공적으로 작동하는데 이렇게 역참조의 행동을 커스터마이징할 수 있는 것이 Deref Trait이다.

```rust
fn deref(&self) -> &Self::Target {
    &self.0
}
```
Trait을 구현하면 위와 같은 메서드를 구현해주어야 하는데, 이 때 튜플에서 특성 .[인덱스]로 Self튜플에서 0번 인덱스를 반환하고 있다.
실제 이코드의 호출부는 다음과 같다. `*(y.deref())`

#### 암묵적 역참조 강제

역참조 강제는 Deref를 구현한 어떤 타입의 참조자를 다른 타입의 참조자로 바꿔준다. 대표적으로 
&String을 &str으로 바꿀 수 있는데, 이러한 행위가 암묵적으로 역참조가 강제가 되었기 때문이다.

#### 역참조 강제 트리거

1. T: Deref<Target=U>일 때 &T에서 &U로 변환
2. T: DerefMut<Target=U>일 때 &mut T에서 &mut U로 변환
3. T: Deref<Target=U>일 때 &mut T에서 &U로 변환

&T가 있을 때 T -> U에 대해 Deref이 구현되어 있다면 &U를 얻을 수 있다.

가변 참조자로 하여금 불변 참조자로 변환할 수 있으나, 그 역은 성립이 안됨 ( 가변 참조자는 유일한 참조자여야 하기 때문 )

### Drop Trait

스코프 밖으로 데이터가 벗어날때의 대한 커스터마이징을 할 수 있다. ( 보통 I/O닫기, Heap메모리 해제에서 사용 )

Drop이 호출되는 순서가 { A -> B -> C } 의 구문이 있을 때 { C -> B -> A } 순으로 Drop이 호출된다고 보면된다 ( 스택이기에 )

#### 일찍 값 버리기

```rust
c.drop();  -> drop(c);
```
rust는 drop메서드를 허용해주지 않는다. 따라서 std::mem::drop을 사용해야 한다.



## Box<T>

Box는 단순하게 Stack이 아닌 Heap에 저장하는 스마트 포인터이다. 주로 아래와 같이 사용 된다.

1. 컴파일 타임에는 크기를 알 수 없으나, 고정된 크기를 해당 컨텍스트에서 사용하고 싶을 때
2. 커다란 데이터의 소유권을 옮기고 싶으면서 데이터 복사를 원치 않을 때
3. 구체화된 타입이 아닌 Trait타입에 대해 의존하고 싶을 떄

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```
위와 같이 사용하며, 단일 값이아닌 데이터가 큰 값에 대해 주로 Heap에 저장할 것 이다.

### 재귀적 타입에서의 사용

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```
위 코드를 통해 `(1, (2, (3, Nil)))`와 같은 수식을 만들게 되면, 사실 컴파일러 입장에서는 List타입의 크기를 가늠할 수 없어 무한히 커지게되며,
실제로 컴파일을 시도하면 recursive without indirection 에러가 발생한다.

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```
이 때 Box타입을 사용하면 좋은데, 이렇게 되면 List는 i32의 사이즈와, Box<List>의 Point주소 사이즈만 계산하면 되므료 사이즈를 유한한 선에서 책정할 수 있게 된다.

