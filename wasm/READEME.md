# WASM

### 이해

1. WebAssembly는 효율적인 실행과 간결한 표현을 위해 설계된 Low Level 형식(가상 ISA)으로 웹에서 고성능 애플리케이션을 구현하는 것이 주된 목표이다.
( 웹외 환경에서도 사용할 수 있음 )

2. WASM의 경우 선형메모리 모델(바이트 배열)이라는 매우 간단한 모델을 가지고 있다. 이 메모리는 64KB씩 커질 수 있으며 축소될 수 없다.

3. `.wasm`바이너리는 Wasm machine위에서 동작하는데, 이 때 앞서 설명한 ISA를 해당 플랫폼의 기계어로 번역하여 즉시 실행한다.
머신의 경우 대표적으로 V8(Chrome), Chakra(Edge), JavaScriptCore(Safari), WASI(웹 외부 환경)이 존재한다.


### 목표

1. Fast : 최신 하드웨어의 공통된 기능을 활용하여 네이티브 코드에 준하는 성능으로 실행 됨
2. Safe : 컴파일에 코드가 검증되며, 메모리가 안전한 샌드박스 환경에서 실행 됨
3. Hardware-independent : 하드웨어로부터 독립적. 데스크톱, 모바일, 임베디드 등 모든 시스템에서 컴파일이 가능
4. Language-independent : 언어로부터 자유로움
5. Platform-independent : 브라우저에 임베디드되거나 독립형 VM으로 실행되거나 다른 환경에 통합될 수 있음
6. Compact : 파일크기가 작아 전송속도가 빠른 바이너리 형식
7. Modular : 프로그램을 더 작게 모듈해 캐싱성능을 누릴 수 있음
8. Efficient : JIT, AOT와 동일하게 디코딩, 유효성 검사, 컴파일이 가능
9. Parallelizable : 디코딩, 컴파일에 대해 병렬작업이 가능

### 시맨틱 단계

- Decoding : WASM모듈은 바이너리 형식으로 배포 된다. 쉽게 말해 컴파일 단계
- Validation : 디코딩된 모듈에 대해 안전하고 의미있는지 유효성 검사를 진행한다. ex) 함수와 그 본문에 대한 타입검사
- Execution : 모듈을 실행한다. 실행 스택을 관리하며, 전역 메모리 및 테이블을 초기화하고 모듈의 main함수를 호출한다.

## Why Rust

- 메모리 : Rust는 고수준의 설계와 저수준의 제어가 가능하다. 이는 Javascript의 고질적인 문제인 GC, 동적 타입체크 기능을 개선할 수 있다
쉽게 말해 GC가 없고, 메모리를 레이아웃을 직접 제어할 수 있다.

- 파일 사이즈 : Rust에는 GC가 없기에 파일크기가 작아야하는 `.wasm`에 어울린다.
